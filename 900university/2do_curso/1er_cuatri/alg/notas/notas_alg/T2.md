# Tema 2: Estructuras de Datos Fundamentales

Este tema abarca un conjunto de estructuras de datos esenciales para el diseño de algoritmos eficientes. Cada una ofrece soluciones optimizadas para diferentes tipos de problemas de almacenamiento y recuperación de información.

## 1. Estructuras de Datos Lineales

### 1.1. Pilas (Stacks)
- **Principio:** LIFO (Last-In, First-Out). El último elemento en entrar es el primero en salir.
- **Operaciones Principales:**
    - `push(elemento)`: Añade un elemento a la cima.
    - `pop()`: Elimina y devuelve el elemento de la cima.
    - `peek()` o `top()`: Devuelve el elemento de la cima sin eliminarlo.
- **Complejidad:** Todas las operaciones son **`O(1)`**.
- **Pseudocódigo (Implementación con Vector):**
  ```
  procedimiento Apilar ( x, P )
    si P.Cima_de_pila = Tamaño_máximo_de_pila entonces
      error Pila llena
    sino
      P.Cima_de_pila := P.Cima_de_pila + 1;
      P.Vector_de_pila[P.Cima_de_pila] := x
    fin si
  fin procedimiento
  ```
- **Implementación en Python:**
  ```python
  class Stack:
      def __init__(self):
          self._data = []

      def push(self, e):
          self._data.append(e)

      def pop(self):
          if not self._data:
              raise IndexError("pop from empty stack")
          return self._data.pop()

      def peek(self):
          if not self._data:
              raise IndexError("peek from empty stack")
          return self._data[-1]

      def is_empty(self):
          return len(self._data) == 0
  ```

### 1.2. Colas (Queues)
- **Principio:** FIFO (First-In, First-Out). El primer elemento en entrar es el primero en salir.
- **Operaciones Principales:**
    - `enqueue(elemento)`: Añade un elemento al final.
    - `dequeue()`: Elimina y devuelve el elemento del frente.
    - `front()`: Devuelve el elemento del frente sin eliminarlo.
- **Complejidad:** Todas las operaciones son **`O(1)`** (usando implementaciones eficientes como arrays circulares o listas doblemente enlazadas).
- **Pseudocódigo (Array Circular):**
  ```
  procedimiento Insertar_en_Cola ( x, C )
    si C.Tamaño_de_Cola = Tamaño_máximo_de_cola entonces
      error Cola llena
    sino
      C.Tamaño_de_cola := C.Tamaño_de_cola + 1;
      incrementar(C.Final_de_cola); // Lógica circular
      C.Vector_de_cola[C.Final_de_cola] := x;
    fin si
  fin procedimiento
  ```
- **Implementación en Python:**
  ```python
  from collections import deque

  # La forma más sencilla en Python es usar collections.deque
  # que está implementado con una lista doblemente enlazada.
  queue = deque()
  queue.append('a') # Enqueue
  queue.append('b')
  print(queue.popleft()) # Dequeue -> 'a'
  ```

## 2. Estructuras de Datos No Lineales y Jerárquicas

### 2.1. Árboles Binarios de Búsqueda (BST)
- **Propiedad:** Para cualquier nodo `N`, todos los valores en su subárbol izquierdo son menores que `N.valor`, y todos los valores en su subárbol derecho son mayores.
- **Operaciones:** `insert`, `search`, `delete`.
- **Complejidad:**
    - **Caso Promedio (árbol balanceado):** `O(log n)`
    - **Peor Caso (árbol degenerado, como una lista):** `O(n)`
- **Pseudocódigo (Insertar):**
  ```
  procedimiento Insertar(x, var A)
    si A = nil entonces
      nuevo(A);
      A^.Elemento := x;
      A^.Izquierdo := nil; A^.Derecho := nil
    sino si x < A^.Elemento entonces
      Insertar(x, A^.Izquierdo)
    sino si x > A^.Elemento entonces
      Insertar(x, A^.Derecho)
    fin si
  fin procedimiento
  ```
- **Implementación en Python:**
  ```python
  class TreeNode:
      def __init__(self, key):
          self.left = None
          self.right = None
          self.val = key

  def insert(root, key):
      if root is None:
          return TreeNode(key)
      else:
          if root.val < key:
              root.right = insert(root.right, key)
          else:
              root.left = insert(root.left, key)
      return root
  ```

### 2.2. Montículos (Heaps) y Colas de Prioridad
- **Concepto:** Un montículo es un árbol binario completo que satisface la "propiedad del montículo": en un min-heap, cada nodo es menor o igual que sus hijos; en un max-heap, es mayor o igual.
- **Uso Principal:** Implementación eficiente de **Colas de Prioridad**.
- **Operaciones:** `insert`, `extract_min` (o `extract_max`).
- **Complejidad:** `O(log n)` para inserciones y extracciones. `O(n)` para construir un montículo desde cero.
- **Pseudocódigo (Hundir - para mantener la propiedad):**
  ```
  procedimiento Hundir ( M, i ) { privado }
    repetir
      HijoIzq := 2*i;
      HijoDer := 2*i+1;
      j := i;
      si HijoDer <= M.Tamaño_monticulo y M.Vector_montículo[HijoDer] > M.Vector_montículo[i] entonces
        i := HijoDer;
      si HijoIzq <= M.Tamaño_monticulo y M.Vector_montículo[HijoIzq] > M.Vector_montículo[i] entonces
        i := HijoIzq;
      intercambiar M.Vector_montículo[j] y M.Vector_montículo[i];
    hasta j=i
  fin procedimiento
  ```
- **Implementación en Python:** Python tiene el módulo `heapq` que implementa un min-heap.
  ```python
  import heapq
  
  pq = []
  heapq.heappush(pq, (2, 'task1')) # (prioridad, dato)
  heapq.heappush(pq, (1, 'task2'))
  
  # Extraer el de menor prioridad
  priority, task = heapq.heappop(pq) # -> (1, 'task2')
  ```

### 2.3. Tablas de Dispersión (Hash Tables)
- **Objetivo:** Lograr inserciones, borrados y búsquedas en tiempo promedio **`O(1)`**.
- **Funcionamiento:** Una **función de hash** mapea una clave a un índice de un vector. Las colisiones (dos claves mapean al mismo índice) son inevitables y deben resolverse.
- **Resolución de Colisiones:**
    1.  **Encadenamiento (Separate Chaining):** Cada posición del vector es una lista de los elementos que colisionaron allí.
    2.  **Direccionamiento Abierto (Open Addressing):** Se busca una celda libre alternativa (exploración lineal, cuadrática o doble hash).
- **Implementación en Python:** El `dict` y el `set` de Python son tablas de hash.
  ```python
  # Uso directo del diccionario de Python
  my_dict = {}
  my_dict['nombre'] = 'Sebastian' # Inserción O(1) promedio
  print('nombre' in my_dict)       # Búsqueda O(1) promedio
  ```

### 2.4. Grafos
- **Definición:** Un par `G = (V, A)` donde `V` es un conjunto de vértices (nodos) y `A` es un conjunto de aristas (conexiones).
- **Representaciones:**
    1.  **Matriz de Adyacencia:** Matriz `|V|x|V|`. Bueno para grafos densos.
    2.  **Lista de Adyacencia:** Un vector donde cada posición `i` contiene una lista de los vecinos del vértice `i`. Eficiente para grafos dispersos (`O(|V|+|A|)` en espacio).

### 2.5. Conjuntos Disjuntos (Disjoint Set Union - DSU)
- **Propósito:** Mantiene una colección de conjuntos disjuntos y permite saber eficientemente si dos elementos pertenecen al mismo conjunto y unir dos conjuntos.
- **Operaciones:**
    - `find(i)`: Devuelve el representante del conjunto al que pertenece `i`.
    - `union(i, j)`: Une los conjuntos a los que pertenecen `i` y `j`.
- **Optimización Clave:** Con **unión por rango/altura** y **compresión de caminos**, las operaciones tienen una complejidad amortizada casi constante, `O(α(n))`, donde `α(n)` es la inversa de la función de Ackermann, que es extremadamente lenta en crecer.

---

## 3. Ejercicio Guiado: Algoritmo de Kruskal para el Árbol de Recubrimiento Mínimo (MST)

Este ejercicio integra **Grafos**, **Colas de Prioridad (Montículos)** y **Conjuntos Disjuntos** para resolver un problema clásico.

**Problema:** Dado un grafo no dirigido y ponderado, encontrar un subconjunto de aristas que conecte todos los vértices (un árbol) con el mínimo peso total posible.

**Algoritmo de Kruskal:**
1.  Crear una lista de todas las aristas del grafo.
2.  Ordenar las aristas por peso de menor a mayor. (Aquí es donde una cola de prioridad es ideal).
3.  Inicializar una estructura de Conjuntos Disjuntos (DSU) con cada vértice en su propio conjunto.
4.  Iterar por las aristas ordenadas:
    - Para cada arista `(u, v)` con peso `w`:
    - Si `find(u)` no es igual a `find(v)` (es decir, `u` y `v` no están ya conectados):
        - Añadir la arista al árbol de recubrimiento.
        - Unir los conjuntos de `u` y `v`: `union(u, v)`.
5.  El algoritmo termina cuando el árbol de recubrimiento tiene `|V|-1` aristas.

### Implementación en Python

```python
# 1. Estructura para Conjuntos Disjuntos (DSU) con optimizaciones
class DSU:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, i):
        if self.parent[i] == i:
            return i
        # Compresión de caminos
        self.parent[i] = self.find(self.parent[i])
        return self.parent[i]

    def union(self, i, j):
        root_i = self.find(i)
        root_j = self.find(j)
        if root_i != root_j:
            # Unión por rango (altura)
            if self.rank[root_i] > self.rank[root_j]:
                self.parent[root_j] = root_i
            elif self.rank[root_i] < self.rank[root_j]:
                self.parent[root_i] = root_j
            else:
                self.parent[root_j] = root_i
                self.rank[root_i] += 1
            return True
        return False

# 2. Grafo y Algoritmo de Kruskal
class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.edges = []

    def add_edge(self, u, v, w):
        self.edges.append((w, u, v)) # (peso, origen, destino)

    def kruskal_mst(self):
        # Usar una cola de prioridad (montículo) es más eficiente,
        # pero para simplicidad, aquí solo ordenamos la lista.
        self.edges.sort()
        
        mst = []
        dsu = DSU(self.V)
        
        num_edges = 0
        for w, u, v in self.edges:
            if num_edges == self.V - 1:
                break
            
            if dsu.union(u, v):
                mst.append((u, v, w))
                num_edges += 1
        
        return mst

# --- Ejemplo de uso ---
# Grafo con 4 vértices (0, 1, 2, 3)
g = Graph(4)
g.add_edge(0, 1, 10)
g.add_edge(0, 2, 6)
g.add_edge(0, 3, 5)
g.add_edge(1, 3, 15)
g.add_edge(2, 3, 4)

# Encontrar el MST
minimum_spanning_tree = g.kruskal_mst()

print("Aristas en el Árbol de Recubrimiento Mínimo:")
total_weight = 0
for u, v, w in minimum_spanning_tree:
    print(f"Arista: {u}-{v}, Peso: {w}")
    total_weight += w
print(f"Peso Total: {total_weight}")

```
**Discusión del Ejemplo:**
1.  Las aristas se ordenan por peso: `(2,3,4)`, `(0,3,5)`, `(0,2,6)`, `(0,1,10)`, `(1,3,15)`.
2.  **Paso 1:** Se procesa `(2,3,4)`. `find(2)` != `find(3)`. Se añade al MST. `union(2,3)`. MST: `[(2,3,4)]`.
3.  **Paso 2:** Se procesa `(0,3,5)`. `find(0)` != `find(3)`. Se añade al MST. `union(0,3)`. MST: `[(2,3,4), (0,3,5)]`. Ahora {0,2,3} están en el mismo conjunto.
4.  **Paso 3:** Se procesa `(0,2,6)`. `find(0)` es igual a `find(2)`. Se forma un ciclo. Se descarta.
5.  **Paso 4:** Se procesa `(0,1,10)`. `find(0)` != `find(1)`. Se añade al MST. `union(0,1)`. MST: `[(2,3,4), (0,3,5), (0,1,10)]`.
6.  El MST ya tiene `V-1 = 3` aristas. El algoritmo termina. El peso total es 4+5+10 = 19.

Este ejercicio demuestra cómo estructuras de datos avanzadas se combinan para resolver un problema complejo de manera eficiente.
