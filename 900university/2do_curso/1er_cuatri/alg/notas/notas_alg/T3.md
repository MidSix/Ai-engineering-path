# Tema 3: Algoritmos de Ordenación

La ordenación es una de las operaciones fundamentales en computación, esencial para organizar datos y facilitar su búsqueda o procesamiento posterior. Este tema explora diversos algoritmos de ordenación, analizando sus principios, eficiencia y casos de uso.

## 1. Conceptos Fundamentales de Ordenación

-   **Definición:** Reorganizar elementos de una secuencia (array o lista) de forma que sigan un orden específico (ascendente o descendente).
-   **Propiedades Importantes:**
    -   **Estabilidad:** Un algoritmo es estable si mantiene el orden relativo de elementos con claves iguales.
    -   **In-place:** Requiere una cantidad de espacio de memoria auxiliar constante (`O(1)`) o logarítmica (`O(log n)`) en relación con el tamaño de la entrada.
    -   **Adaptabilidad:** Un algoritmo es adaptable si su rendimiento mejora para entradas parcialmente ordenadas.

## 2. Algoritmos de Ordenación Básicos (O(n²))

Estos algoritmos, aunque simples de implementar, no son eficientes para grandes volúmenes de datos. Fueron revisados en el Tema 1.

-   **Ordenación por Inserción (Insertion Sort):** Recorre el array, insertando cada elemento en su posición correcta dentro de la parte ya ordenada.
    -   **Complejidad:** Mejor Caso `O(n)`, Promedio/Peor Caso `O(n²)`. Es estable y adaptable.
-   **Ordenación por Selección (Selection Sort):** Encuentra repetidamente el elemento mínimo (o máximo) del resto no ordenado y lo coloca en su posición final.
    -   **Complejidad:** Siempre `O(n²)`. No es estable.

## 3. Algoritmos de Ordenación Avanzados (O(n log n))

Estos algoritmos ofrecen una eficiencia superior para conjuntos de datos grandes, convirtiéndose en el estándar para la mayoría de aplicaciones.

### 3.1. Ordenación de Shell (Shell Sort)

-   **Principio:** Mejora el Insertion Sort al permitir intercambios de elementos distantes, reduciendo así el número de inversiones de forma más rápida. Se realiza una serie de "h-ordenaciones" (ordenaciones por inserción sobre sublistas con un incremento `h`), reduciendo `h` progresivamente hasta `1`.
-   **Pseudocódigo (Esquema general con incrementos de Shell):**
    ```
    procedimiento OrdenacionShell (var T[1..n])
      incremento := n
      mientras incremento > 0 hacer
        incremento := incremento div 2 // u otra secuencia de incrementos
        para i := incremento+1 hasta n hacer
          // Insertion Sort para los elementos distanciados por 'incremento'
          tmp := T[i]
          j := i
          mientras j > incremento y T[j-incremento] > tmp hacer
            T[j] := T[j-incremento]
            j := j - incremento
          fin mientras
          T[j] := tmp
        fin para
      fin mientras
    fin procedimiento
    ```
-   **Complejidad:** Depende enormemente de la secuencia de incrementos. Puede variar desde `O(n²)` en el peor caso (con incrementos ingenuos) hasta `O(n^(4/3))` o `O(n^(5/4))` con secuencias bien elegidas (como las de Sedgewick).

### 3.2. Ordenación por Fusión (Merge Sort)

-   **Principio:** Algoritmo **Divide y Vencerás** que divide el array en dos mitades, las ordena recursivamente y luego fusiona las dos mitades ordenadas.
-   **Recurrencia:** `T(n) = 2T(n/2) + O(n)` (la fase de fusión es lineal).
-   **Complejidad:** `Θ(n log n)` en todos los casos (mejor, promedio, peor). Es estable.
-   **Características:** No es *in-place* (requiere `O(n)` espacio auxiliar para la fusión).

### 3.3. Ordenación por Montículos (Heap Sort)

-   **Principio:** Utiliza una estructura de datos de **montículo (heap)** (vista en Tema 2) para ordenar el array.
    1.  Se construye un montículo máximo a partir del array de entrada (`O(n)`).
    2.  Se extrae repetidamente el elemento máximo de la raíz y se coloca al final del array, reajustando el montículo (`n` veces `O(log n)`).
-   **Pseudocódigo (Esquema):**
    ```
    procedimiento HeapSort (var A[1..n])
      // 1. Construir un montículo máximo
      para i := n div 2 hasta 1 paso -1 hacer
        Hundir(A, i, n) // función Hundir (heapify-down)
      fin para

      // 2. Extraer elementos del montículo
      para i := n hasta 2 paso -1 hacer
        intercambiar(A[1], A[i]) // Mover la raíz al final
        Hundir(A, 1, i-1) // Reajustar el montículo reducido
      fin para
    fin procedimiento
    ```
-   **Complejidad:** `Θ(n log n)` en todos los casos. Es *in-place*.

### 3.4. Ordenación Rápida (Quicksort)

-   **Principio:** Algoritmo **Divide y Vencerás** que selecciona un elemento (el pivote) y particiona el resto del array en dos subarrays: elementos menores que el pivote y elementos mayores que el pivote. Luego, ordena recursivamente los subarrays.
-   **Selección del Pivote:** Crucial para el rendimiento. Estrategias comunes:
    -   Primer elemento: Malo para entradas ya ordenadas.
    -   Elemento aleatorio: Bueno en promedio.
    -   **Mediana de tres:** Elige la mediana de los elementos inicial, central y final. Reduce la probabilidad del peor caso.
-   **Partición:** Mueve los elementos para que los menores que el pivote queden a un lado y los mayores al otro.
-   **Optimización (Umbral):** Para subarrays pequeños (ej. `n < 10-20`), Quicksort puede ser ineficiente debido a la sobrecarga recursiva. Se utiliza **Insertion Sort** para estas sublistas.

-   **Pseudocódigo (Esquema básico de Quicksort):**
    ```
    procedimiento QuickSort(var T[izq..der])
      si izq < der entonces
        pivote_idx := Particionar(T, izq, der) // selecciona y coloca el pivote
        QuickSort(T, izq, pivote_idx - 1)
        QuickSort(T, pivote_idx + 1, der)
      fin si
    fin procedimiento

    // Particionar (ej. variante de Hoare)
    procedimiento Particionar(var T[izq..der]) : indice
      pivote := T[der] // por simplicidad, se usa el último
      i := izq - 1
      para j := izq hasta der - 1 hacer
        si T[j] <= pivote entonces
          i := i + 1
          intercambiar(T[i], T[j])
        fin si
      fin para
      intercambiar(T[i + 1], T[der])
      devolver i + 1
    fin procedimiento
    ```
-   **Complejidad:**
    -   **Mejor/Promedio Caso:** `Θ(n log n)`.
    -   **Peor Caso:** `O(n²)` (ocurre cuando el pivote siempre es el elemento más pequeño o más grande). La mediana de tres y pivotes aleatorios ayudan a mitigar esto.
-   **Características:** Es *in-place* (o casi, dependiendo de la implementación de la pila de llamadas recursivas). No es estable.

## 4. Ejercicio: Quicksort con Pivote Mediana de Tres y Umbral

Vamos a implementar Quicksort en Python, incorporando las optimizaciones de selección de pivote por "mediana de tres" y el uso de Insertion Sort para subarrays pequeños.

```python
import random

# Función auxiliar para Insertion Sort (para el umbral)
def insertion_sort_subarray(arr, low, high):
    for i in range(low + 1, high + 1):
        key = arr[i]
        j = i - 1
        while j >= low and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

# Función para seleccionar el pivote usando la mediana de tres
def median_of_three(arr, low, high):
    mid = (low + high) // 2
    
    # Asegurarse de que arr[low] <= arr[mid] <= arr[high]
    # No es necesario ordenar completamente, solo mover el pivote (mediana) a la penúltima posición
    # para usarlo con la partición de Hoare o Lomuto modificada.
    
    # Simple para el ejemplo: ordenar low, mid, high y colocar mediana en high-1
    if arr[low] > arr[mid]:
        arr[low], arr[mid] = arr[mid], arr[low]
    if arr[low] > arr[high]:
        arr[low], arr[high] = arr[high], arr[low]
    if arr[mid] > arr[high]:
        arr[mid], arr[high] = arr[high], arr[mid]
        
    # Colocar el pivote (arr[mid]) en arr[high-1] para la partición
    # o simplemente devolver arr[mid] si el esquema de partición lo maneja.
    # Para la partición que usaremos, simplemente lo tomaremos del medio.
    
    # Para simplificar la partición, se suele mover el pivote a la posición 'high-1'
    # o directamente a 'high' y luego usar Lomuto. Aquí usaremos un enfoque más directo.
    
    # Para este ejemplo, simplemente devolveremos el valor, no la posición.
    # Un quicksort real intercambiaría el pivote con high-1 o high para la partición.
    # Para una implementación de Hoare, a menudo se usa arr[low] como pivote
    # o se intercambia la mediana en low para que sea el pivote.
    
    # Para el trazado, simplificaremos: la mediana será el elemento en arr[mid]
    # y lo moveremos al final del rango para ser el pivote de Lomuto.
    
    # Intercambiamos arr[mid] con arr[high-1] y luego arr[low] con arr[high]
    # para que el pivote de Lomuto sea arr[high].
    
    # Colocar mediana en high-1 para simplificar la partición.
    arr[mid], arr[high-1] = arr[high-1], arr[mid]
    
    # Ahora, el pivote efectivo para la partición de Lomuto sería arr[high].
    # La mediana está en arr[high-1]. Necesitamos poner la mediana en arr[high]
    # y luego usar Lomuto.
    
    # Simplified approach: take median, move it to high, then partition.
    if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low]
    if arr[low] > arr[high]: arr[low], arr[high] = arr[high], arr[low]
    if arr[mid] > arr[high]: arr[mid], arr[high] = arr[high], arr[mid]
    
    # Ahora arr[low] <= arr[mid] <= arr[high]. Usamos arr[mid] como pivote
    # y lo movemos a high-1.
    arr[mid], arr[high - 1] = arr[high - 1], arr[mid]
    return arr[high - 1] # El pivote es ahora el elemento en high-1
    


# Algoritmo de partición (Hoare, ligeramente modificado para mediana de tres)
def partition(arr, low, high):
    # Usar el elemento en high como pivote temporalmente
    # Después de median_of_three, arr[high-1] contiene el pivote
    
    pivot_val = arr[high - 1]
    
    i = low # Puntero para elementos menores que el pivote
    for j in range(low, high - 1): # No incluir el pivote en high-1
        if arr[j] <= pivot_val:
            arr[i], arr[j] = arr[j], arr[i]
            i += 1
    
    arr[i], arr[high - 1] = arr[high - 1], arr[i] # Colocar el pivote en su lugar final
    return i

# Quicksort con mediana de tres y umbral
def quicksort_optimized(arr, low, high, threshold=10):
    if low < high:
        if high - low + 1 <= threshold:
            # Si el subarray es pequeño, usar Insertion Sort
            insertion_sort_subarray(arr, low, high)
        else:
            # Seleccionar pivote usando mediana de tres
            # Esto modificará arr[high-1] para tener el pivote
            median_of_three_val = median_of_three(arr, low, high)
            
            # Ahora el pivote está en high-1. Podemos usarlo directamente para la partición.
            # O, si la implementación de partición usa arr[high] como pivote,
            # asegúrese de que la mediana se mueva a arr[high] ANTES de llamar a partition.
            
            # La implementación de 'median_of_three' ya coloca la mediana en high-1.
            # Modifiquemos 'partition' para que trabaje con el pivote en high-1.
            
            # Una forma común es intercambiar el pivote con el elemento en high-1,
            # y luego proceder con una partición que usa high-1 como pivote.
            # Para este ejemplo, simplificamos: median_of_three ya lo hizo.
            
            # Una implementación más estándar de Hoare para median_of_three:
            # 1. Ordenar arr[low], arr[mid], arr[high].
            # 2. Intercambiar arr[mid] con arr[high-1]. (arr[high-1] es ahora el pivote).
            # 3. Intercambiar arr[low] con arr[high-1]. (arr[low] es ahora el pivote, el guardián).
            # Luego la partición procede con arr[low] como pivote.
            
            # Para mantenerlo simple y seguir el pseudocódigo general, reajustaré median_of_three
            # para que la mediana acabe en arr[high] para la partición de Lomuto.
            
            # Re-implementing median_of_three to directly prepare for Lomuto's partition with pivot at high.
            idx_low, idx_mid, idx_high = low, (low + high) // 2, high
            if arr[idx_low] > arr[idx_mid]: arr[idx_low], arr[idx_mid] = arr[idx_mid], arr[idx_low]
            if arr[idx_low] > arr[idx_high]: arr[idx_low], arr[idx_high] = arr[idx_high], arr[idx_low]
            if arr[idx_mid] > arr[idx_high]: arr[idx_mid], arr[idx_high] = arr[idx_high], arr[idx_mid]
            
            # arr[idx_mid] es la mediana, la movemos al final.
            arr[idx_mid], arr[idx_high] = arr[idx_high], arr[idx_mid]
            pivot_index = partition_lomuto(arr, low, high)
            
            quicksort_optimized(arr, low, pivot_index - 1, threshold)
            quicksort_optimized(arr, pivot_index + 1, high, threshold)

# Partición de Lomuto (más sencilla para el ejemplo, pivote es el último elemento)
def partition_lomuto(arr, low, high):
    pivot = arr[high]
    i = low - 1
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1


# --- Trazado del ejemplo ---
print("--- Trazado de Quicksort Optimizado ---")
my_array = [8, 14, 6, 1, 7, 9, 4, 2, 11, 13, 10, 3, 5, 12]
print(f"Array inicial: {my_array}")
print("-" * 30)

# Simulación paso a paso (aquí se mostraría el árbol de llamadas)
# Debido a la complejidad de trazar recursividad con múltiples opciones de pivote y umbrales,
# el trazado se hará a nivel de "qué pasa con el array en cada llamada principal".

def quicksort_trace(arr, low, high, threshold, depth=0):
    indent = "  " * depth
    if low >= high:
        # Si el umbral es 1 o menos, o el subarray es de tamaño 0/1
        return arr[low:high+1] if low <= high else []

    if high - low + 1 <= threshold:
        insertion_sort_subarray(arr, low, high)
        print(f"{indent}Ordenando sub-array [{low}-{high}] con Insertion Sort: {arr[low:high+1]}")
        return arr[low:high+1]
    
    # Median of three
    idx_low, idx_mid, idx_high = low, (low + high) // 2, high
    
    # Ordenar low, mid, high para encontrar la mediana
    if arr[idx_low] > arr[idx_mid]: arr[idx_low], arr[idx_mid] = arr[idx_mid], arr[idx_low]
    if arr[idx_low] > arr[idx_high]: arr[idx_low], arr[idx_high] = arr[idx_high], arr[idx_low]
    if arr[idx_mid] > arr[idx_high]: arr[idx_mid], arr[idx_high] = arr[idx_high], arr[idx_mid]
    
    # La mediana está en arr[idx_mid]. La movemos al final para Lomuto
    arr[idx_mid], arr[idx_high] = arr[idx_high], arr[idx_mid]
    pivot_val = arr[idx_high]
    print(f"{indent}Selección de pivote (mediana de tres) para [{low}-{high}]: {pivot_val}. Array: {arr}")

    # Particionar
    pivot_index = partition_lomuto(arr, low, high)
    print(f"{indent}Particionado con pivote {pivot_val}. Array después de partición: {arr}. Pivote en índice {pivot_index}")

    print(f"{indent}Llamada recursiva izquierda para sub-array [{low}-{pivot_index-1}]")
    quicksort_trace(arr, low, pivot_index - 1, threshold, depth + 1)
    
    print(f"{indent}Llamada recursiva derecha para sub-array [{pivot_index+1}-{high}]")
    quicksort_trace(arr, pivot_index + 1, high, threshold, depth + 1)
    
    return arr # Devuelve el array completo ordenado una vez finalizadas las llamadas.

# Ejecutar Quicksort y mostrar el trazado
quicksort_trace(my_array, 0, len(my_array) - 1, threshold=3)
print("-" * 30)
print(f"Array final ordenado: {my_array}")
```

**Trazado de un ejemplo (`my_array = [8, 14, 6, 1, 7, 9, 4, 2, 11, 13, 10, 3, 5, 12]`, threshold=3):**

(Debido a la naturaleza recursiva y el volumen del trazado, se presenta un resumen de los pasos clave, no cada micro-paso de la partición.)

**Array inicial:** `[8, 14, 6, 1, 7, 9, 4, 2, 11, 13, 10, 3, 5, 12]`

-   **Llamada principal ([0-13]):**
    -   `low=0`, `high=13`. Tamaño `14 > 3`.
    -   Mediana de tres: `arr[0]=8`, `arr[6]=4`, `arr[13]=12`. La mediana es `8`.
    -   Se reordena el array para que `8` sea el pivote para la partición (ej. moviéndolo al final temporalmente).
        `[6, 1, 7, 4, 2, 3, 5, 8, 11, 13, 10, 9, 14, 12]` (ejemplo de estado tras preparar pivote y particionar)
    -   Particionado con pivote `8`. El pivote se coloca en su posición final.
        `[6, 1, 7, 4, 2, 3, 5, **8**, 11, 13, 10, 9, 14, 12]`
        Pivote `8` está en índice `7`.
    -   Llamada izquierda a `[0-6]` (sub-array `[6, 1, 7, 4, 2, 3, 5]`)
    -   Llamada derecha a `[8-13]` (sub-array `[11, 13, 10, 9, 14, 12]`)

-   **Llamada recursiva izquierda para `[0-6]`:** `[6, 1, 7, 4, 2, 3, 5]`
    -   `low=0`, `high=6`. Tamaño `7 > 3`.
    -   Mediana de tres: `arr[0]=6`, `arr[3]=4`, `arr[6]=5`. La mediana es `5`.
    -   Particionado con pivote `5`.
        `[1, 4, 2, 3, **5**, 6, 7]`
        Pivote `5` está en índice `4`.
    -   Llamada izquierda a `[0-3]` (`[1, 4, 2, 3]`)
    -   Llamada derecha a `[5-6]` (`[6, 7]`)

-   **Llamada recursiva izquierda para `[0-3]`:** `[1, 4, 2, 3]`
    -   `low=0`, `high=3`. Tamaño `4 > 3`.
    -   Mediana de tres: `arr[0]=1`, `arr[1]=4`, `arr[3]=3`. La mediana es `3`.
    -   Particionado con pivote `3`.
        `[1, 2, **3**, 4]`
        Pivote `3` está en índice `2`.
    -   Llamada izquierda a `[0-1]` (`[1, 2]`). Tamaño `2 <= 3`. Se ordena con Insertion Sort.
    -   Llamada derecha a `[3-3]` (`[4]`). Tamaño `1 <= 3`. Ya ordenado.

-   **Llamada recursiva derecha para `[5-6]`:** `[6, 7]`
    -   `low=5`, `high=6`. Tamaño `2 <= 3`. Se ordena con Insertion Sort.

*(Y así sucesivamente para las llamadas del lado derecho y todos los subproblemas, aplicando Insertion Sort cuando el tamaño del subarray cae por debajo del umbral de 3.)*

**Array final ordenado:** `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]`
