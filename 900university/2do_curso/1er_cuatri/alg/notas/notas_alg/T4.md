# Tema 4: Algoritmos Voraces

Los algoritmos voraces (o ávidos, del inglés *greedy*) son una estrategia de diseño algorítmico para resolver problemas de optimización. La idea es simple pero potente: en cada paso, tomar la decisión que parezca la mejor en ese momento (óptimo local), con la esperanza de que la secuencia de óptimos locales conduzca a una solución óptima global.

## 1. Características de los Algoritmos Voraces

Un problema debe tener ciertas propiedades para que un algoritmo voraz garantice una solución óptima:

-   **Subproblemas óptimos:** Una solución óptima global contiene soluciones óptimas a los subproblemas.
-   **Elección voraz:** Se puede llegar a una solución óptima global tomando siempre la decisión que parece mejor a nivel local. Una vez que se toma una decisión, no se reconsidera (no hay *backtracking*).

El esquema general de un algoritmo voraz es:
1.  Empezar con un conjunto de candidatos.
2.  En cada paso, seleccionar el "mejor" candidato según una función de selección.
3.  Verificar si el candidato es "factible" (puede formar parte de la solución).
4.  Si es factible, añadirlo al conjunto de la solución.
5.  Repetir hasta que se complete la solución.

### 1.1. Ejemplo Clásico: El Problema del Cambio de Monedas

**Problema:** Dar cambio para una cantidad `n` usando el menor número posible de monedas de un sistema monetario `M`.

**Estrategia Voraz:** En cada paso, elegir la moneda de mayor valor que no exceda la cantidad restante.

-   **Ejemplo funcional:** Sistema monetario `M = {1, 2, 5, 10, 20, 50}` y `n = 48`.
    1.  Elegimos `20`. Restan `28`. Solución: `{20}`.
    2.  Elegimos `20`. Restan `8`. Solución: `{20, 20}`.
    3.  Elegimos `5`. Restan `3`. Solución: `{20, 20, 5}`.
    4.  Elegimos `2`. Restan `1`. Solución: `{20, 20, 5, 2}`.
    5.  Elegimos `1`. Restan `0`. Solución: `{20, 20, 5, 2, 1}`.
    Esta es la solución óptima.

-   **Ejemplo no funcional:** Sistema `M = {1, 4, 6}` y `n = 8`.
    -   **Solución Voraz:** Elige `6`. Restan `2`. Elige `1`. Restan `1`. Elige `1`. Restan `0`. Solución: `{6, 1, 1}` (3 monedas).
    -   **Solución Óptima:** `{4, 4}` (2 monedas).
    -   **Conclusión:** La estrategia voraz no siempre funciona. Su éxito depende de la estructura del problema (en este caso, del sistema monetario).

### 1.2. Problema de la Mochila Fraccionaria

**Problema:** Tienes una mochila con capacidad de peso `W` y un conjunto de objetos, cada uno con un `peso` y un `valor`. Quieres maximizar el valor total de los objetos en la mochila, y puedes llevar fracciones de objetos.

**Estrategia Voraz:** Calcular la "rentabilidad" de cada objeto (`valor/peso`) y añadir a la mochila los objetos (o fracciones de ellos) en orden decreciente de rentabilidad.

Esta estrategia **sí garantiza la solución óptima** para la versión fraccionaria.

-   **Complejidad:** `O(n log n)` si se necesita ordenar los objetos por rentabilidad.

## 2. Algoritmos Voraces en Grafos

### 2.1. Árbol de Recubrimiento Mínimo (MST)

**Problema:** Dado un grafo no dirigido, conexo y ponderado, encontrar un subgrafo que sea un árbol, conecte todos los vértices y cuyo coste total (la suma de los pesos de las aristas) sea mínimo.

-   **Algoritmo de Kruskal:**
    -   **Estrategia Voraz:** Ordenar todas las aristas del grafo por peso de menor a mayor. Iterar sobre ellas y añadir una arista al MST solo si no forma un ciclo con las ya añadidas.
    -   **Estructuras:** Utiliza una estructura de datos de **Conjuntos Disjuntos (DSU)** para detectar ciclos eficientemente.
    -   **Complejidad:** `O(m log m)` o `O(m log n)` donde `m` es el número de aristas y `n` el de vértices, dominada por la ordenación de las aristas.

-   **Algoritmo de Prim:**
    -   **Estrategia Voraz:** Empezar desde un vértice arbitrario. En cada paso, añadir la arista de menor peso que conecte un vértice del árbol en construcción con un vértice que aún no está en el árbol.
    -   **Estructuras:** Utiliza una **cola de prioridad** para encontrar eficientemente la arista de menor peso.
    -   **Complejidad:** `O(m log n)` o `O(m + n log n)` con una cola de prioridad basada en montículos de Fibonacci.

---

## 3. Ejercicio Guiado: Algoritmo de Dijkstra para Caminos Mínimos

Este ejercicio es uno de los problemas fundamentales en grafos y un ejemplo perfecto de algoritmo voraz. Resuelve el problema de encontrar los caminos más cortos desde un único nodo origen a todos los demás nodos en un grafo dirigido y ponderado, **siempre que no haya pesos de arista negativos**.

**Problema:** Dado el siguiente grafo dirigido, encontrar las distancias mínimas desde el nodo `A` a todos los demás.

![Grafo de ejemplo para Dijkstra](https://i.imgur.com/gS4s9Op.png)

### Parte 1: Pseudocódigo y Lógica

El algoritmo de Dijkstra mantiene un conjunto de vértices "visitados" para los cuales la distancia mínima desde el origen ya es definitiva.

**Estructuras de datos necesarias:**
1.  `distancias`: Un array para almacenar la distancia mínima conocida desde el origen hasta cada nodo. Se inicializa a `∞` para todos los nodos, excepto para el origen, que es `0`.
2.  `predecesores`: Un array para reconstruir los caminos, guardando qué nodo precede a cuál en el camino más corto.
3.  `cola_prioridad`: Una cola de prioridad (min-heap) que almacena tuplas `(distancia, nodo)`. Nos permite obtener siempre el nodo no visitado más cercano al origen.

**Pseudocódigo:**
```
función Dijkstra(Grafo, origen)
  para cada vertice v en Grafo:
    distancias[v] := ∞
    predecesores[v] := nulo
  distancias[origen] := 0

  cola_prioridad := new ColaDePrioridad()
  añadir (0, origen) a cola_prioridad

  mientras cola_prioridad no esté vacía:
    dist, u := extraer_min(cola_prioridad)

    // Si ya encontramos un camino más corto a u, ignoramos esta entrada
    si dist > distancias[u]:
      continuar

    para cada vecino v de u:
      peso_arista := peso(u, v)
      nueva_dist := distancias[u] + peso_arista
      
      si nueva_dist < distancias[v]:
        distancias[v] := nueva_dist
        predecesores[v] := u
        añadir (nueva_dist, v) a cola_prioridad

  devolver distancias, predecesores
fin función
```

### Parte 2: Trazado Paso a Paso

**Grafo:**
-   Nodos: `{A, B, C, D, E, F, G, H}`
-   Origen: `A`

**Inicialización:**
-   `distancias`: `{A:0, B:∞, C:∞, D:∞, E:∞, F:∞, G:∞, H:∞}`
-   `cola_prioridad`: `[(0, A)]`
-   Visitados: `{}`

---

**Iteración 1:**
1.  `extraer_min`: `(0, A)`.
2.  **Nodo actual:** `A`. Añadir `A` a visitados. `Visitados: {A}`.
3.  **Vecinos de A:** `D` y `F`.
    -   **Vía A->D:** `dist(D) = ∞`. `dist(A)+peso(A,D) = 0+1 = 1`. Actualizamos: `dist(D)=1`, `pred(D)=A`. Añadir `(1, D)` a la cola.
    -   **Vía A->F:** `dist(F) = ∞`. `dist(A)+peso(A,F) = 0+2 = 2`. Actualizamos: `dist(F)=2`, `pred(F)=A`. Añadir `(2, F)` a la cola.
-   `cola_prioridad`: `[(1, D), (2, F)]`
-   `distancias`: `{A:0, B:∞, C:∞, D:1, E:∞, F:2, G:∞, H:∞}`

---

**Iteración 2:**
1.  `extraer_min`: `(1, D)`.
2.  **Nodo actual:** `D`. `Visitados: {A, D}`.
3.  **Vecinos de D:** `H`.
    -   **Vía D->H:** `dist(H) = ∞`. `dist(D)+peso(D,H) = 1+1 = 2`. Actualizamos: `dist(H)=2`, `pred(H)=D`. Añadir `(2, H)` a la cola.
-   `cola_prioridad`: `[(2, F), (2, H)]` (el orden entre F y H puede variar)
-   `distancias`: `{A:0, B:∞, C:∞, D:1, E:∞, F:2, G:∞, H:2}`

---

**Iteración 3:**
1.  `extraer_min`: `(2, F)` (suponiendo que sale antes que H).
2.  **Nodo actual:** `F`. `Visitados: {A, D, F}`.
3.  **Vecinos de F:** `B`, `C`, `G`.
    -   **Vía F->B:** `dist(B) = ∞`. `dist(F)+peso(F,B) = 2+4 = 6`. Actualizamos: `dist(B)=6`, `pred(B)=F`. Añadir `(6, B)` a la cola.
    -   **Vía F->C:** `dist(C) = ∞`. `dist(F)+peso(F,C) = 2+9 = 11`. Actualizamos: `dist(C)=11`, `pred(C)=F`. Añadir `(11, C)` a la cola.
    -   **Vía F->G:** `dist(G) = ∞`. `dist(F)+peso(F,G) = 2+7 = 9`. Actualizamos: `dist(G)=9`, `pred(G)=F`. Añadir `(9, G)` a la cola.
-   `cola_prioridad`: `[(2, H), (6, B), (9, G), (11, C)]`
-   `distancias`: `{A:0, B:6, C:11, D:1, E:∞, F:2, G:9, H:2}`

---

**Iteración 4:**
1.  `extraer_min`: `(2, H)`.
2.  **Nodo actual:** `H`. `Visitados: {A, D, F, H}`.
3.  **Vecinos de H:** `E`, `G`.
    -   **Vía H->E:** `dist(E) = ∞`. `dist(H)+peso(H,E) = 2+1 = 3`. Actualizamos: `dist(E)=3`, `pred(E)=H`. Añadir `(3, E)` a la cola.
    -   **Vía H->G:** `dist(G) = 9`. `dist(H)+peso(H,G) = 2+8 = 10`. `10` no es menor que `9`. No actualizamos.
-   `cola_prioridad`: `[(3, E), (6, B), (9, G), (11, C)]`
-   `distancias`: `{A:0, B:6, C:11, D:1, E:3, F:2, G:9, H:2}`

---

**Iteración 5:**
1.  `extraer_min`: `(3, E)`.
2.  **Nodo actual:** `E`. `Visitados: {A, D, F, H, E}`.
3.  **Vecinos de E:** `G`.
    -   **Vía E->G:** `dist(G) = 9`. `dist(E)+peso(E,G) = 3+2 = 5`. `5` es menor que `9`. Actualizamos: `dist(G)=5`, `pred(G)=E`. Añadir `(5, G)` a la cola.
-   `cola_prioridad`: `[(5, G), (6, B), (9, G), (11, C)]` (Nótese que hay un `(9,G)` obsoleto).
-   `distancias`: `{A:0, B:6, C:11, D:1, E:3, F:2, G:5, H:2}`

---

**Iteración 6:**
1.  `extraer_min`: `(5, G)`.
2.  **Nodo actual:** `G`. `Visitados: {A, D, F, H, E, G}`.
3.  No tiene vecinos de salida.
-   `cola_prioridad`: `[(6, B), (9, G), (11, C)]`

---

**Iteración 7:**
1.  `extraer_min`: `(6, B)`.
2.  **Nodo actual:** `B`. `Visitados: {A, D, F, H, E, G, B}`.
3.  **Vecinos de B:** `C`.
    -   **Vía B->C:** `dist(C) = 11`. `dist(B)+peso(B,C) = 6+1 = 7`. `7` es menor que `11`. Actualizamos: `dist(C)=7`, `pred(C)=B`. Añadir `(7, C)` a la cola.
-   `cola_prioridad`: `[(7, C), (9, G), (11, C)]`

---

**Iteración 8:**
1.  `extraer_min`: `(7, C)`.
2.  **Nodo actual:** `C`. `Visitados: {A, D, F, H, E, G, B, C}`.
3.  No tiene vecinos de salida.

---

**Final:** La cola de prioridad se vacía (las entradas restantes son obsoletas).

**Resultados Finales:**

| Nodo | Distancia Mínima | Camino más corto (reconstruido) |
| :--- | :--------------- | :------------------------------ |
| A    | 0                | A                               |
| B    | 6                | A -> F -> B                     |
| C    | 7                | A -> F -> B -> C                |
| D    | 1                | A -> D                          |
| E    | 3                | A -> D -> H -> E                |
| F    | 2                | A -> F                          |
| G    | 5                | A -> D -> H -> E -> G           |
| H    | 2                | A -> D -> H                     |

### Parte 3: Implementación en Python

```python
import heapq

def dijkstra(graph, start_node):
    """
    Implementación del algoritmo de Dijkstra usando una cola de prioridad (min-heap).
    
    Args:
        graph (dict): Un diccionario que representa el grafo. 
                      Ej: {'A': {'D': 1, 'F': 2}, 'B': {'C': 1}, ...}
        start_node (str): El nodo de inicio.

    Returns:
        tuple: (distancias, predecesores)
    """
    
    # 1. Inicialización
    distances = {node: float('inf') for node in graph}
    predecessors = {node: None for node in graph}
    distances[start_node] = 0
    
    # La cola de prioridad almacena tuplas (distancia, nodo)
    pq = [(0, start_node)]
    
    while pq:
        # 2. Extraer el nodo no visitado más cercano
        current_distance, current_node = heapq.heappop(pq)
        
        # Si ya hemos encontrado un camino mejor, saltamos
        if current_distance > distances[current_node]:
            continue
            
        # 3. Explorar vecinos
        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight
            
            # 4. Relajación: si encontramos un camino más corto, actualizamos
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                predecessors[neighbor] = current_node
                heapq.heappush(pq, (distance, neighbor))
                
    return distances, predecessors

# --- Ejemplo de uso ---

# Definimos el grafo del ejercicio
# Se incluyen nodos sin aristas de salida para que estén en el grafo
graph_example = {
    'A': {'D': 1, 'F': 2},
    'B': {'C': 1},
    'C': {},
    'D': {'H': 1},
    'E': {'G': 2},
    'F': {'B': 4, 'C': 9, 'G': 7},
    'G': {},
    'H': {'E': 1, 'G': 8}
}

# Ejecutar Dijkstra desde el nodo 'A'
distances, predecessors = dijkstra(graph_example, 'A')

# Imprimir resultados
print("Distancias mínimas desde A:")
for node, dist in distances.items():
    print(f"  - A hasta {node}: {dist}")

print("\nCaminos más cortos:")
for node in graph_example:
    path = []
    current = node
    while current is not None:
        path.insert(0, current)
        current = predecessors[current]
    
    if distances[node] != float('inf'):
        print(f"  - A -> {node}: {' -> '.join(path)}")

```
Este ejercicio demuestra cómo la elección voraz de Dijkstra (expandir siempre el nodo no visitado más cercano) construye progresivamente el conjunto de caminos mínimos desde el origen.
